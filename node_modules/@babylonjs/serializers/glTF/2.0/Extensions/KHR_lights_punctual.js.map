{"version":3,"file":"KHR_lights_punctual.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"],"names":[],"mappings":"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","sourcesContent":["import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { _Exporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { _GLTFUtilities } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: _Exporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: _Exporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter!._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of unique id to glTF node index\r\n     * @returns nullable INode promise\r\n     */\r\n    public postExportNodeAsync(context: string, node: Nullable<INode>, babylonNode: Node, nodeMap: { [key: number]: number }): Promise<Nullable<INode>> {\r\n        return new Promise((resolve) => {\r\n            if (node && babylonNode instanceof ShadowLight) {\r\n                let light: IKHRLightsPunctual_Light;\r\n\r\n                const lightType =\r\n                    babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                        ? KHRLightsPunctual_LightType.POINT\r\n                        : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                          ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                          : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                            ? KHRLightsPunctual_LightType.SPOT\r\n                            : null;\r\n                if (lightType == null) {\r\n                    Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                } else {\r\n                    if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                        node.translation = babylonNode.position.asArray();\r\n                    }\r\n                    if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                        const localAxis = babylonNode.direction;\r\n                        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;\r\n                        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);\r\n                        const pitch = -Math.atan2(localAxis.y, len);\r\n                        const lightRotationQuaternion = Quaternion.RotationYawPitchRoll(yaw + Math.PI, pitch, 0);\r\n                        if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                            node.rotation = lightRotationQuaternion.asArray();\r\n                        }\r\n                    }\r\n\r\n                    if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                        Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n                    }\r\n                    light = {\r\n                        type: lightType,\r\n                    };\r\n                    if (!babylonNode.diffuse.equals(Color3.White())) {\r\n                        light.color = babylonNode.diffuse.asArray();\r\n                    }\r\n                    if (babylonNode.intensity !== 1.0) {\r\n                        light.intensity = babylonNode.intensity;\r\n                    }\r\n                    if (babylonNode.range !== Number.MAX_VALUE) {\r\n                        light.range = babylonNode.range;\r\n                    }\r\n\r\n                    if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                        const babylonSpotLight = babylonNode as SpotLight;\r\n                        if (babylonSpotLight.angle !== Math.PI / 2.0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.outerConeAngle = babylonSpotLight.angle / 2.0;\r\n                        }\r\n                        if (babylonSpotLight.innerAngle !== 0) {\r\n                            if (light.spot == null) {\r\n                                light.spot = {};\r\n                            }\r\n                            light.spot.innerConeAngle = babylonSpotLight.innerAngle / 2.0;\r\n                        }\r\n                    }\r\n\r\n                    this._lights ||= {\r\n                        lights: [],\r\n                    };\r\n\r\n                    this._lights.lights.push(light);\r\n\r\n                    const lightReference: IKHRLightsPunctual_LightReference = {\r\n                        light: this._lights.lights.length - 1,\r\n                    };\r\n\r\n                    // Avoid duplicating the Light's parent node if possible.\r\n                    const parentBabylonNode = babylonNode.parent;\r\n                    if (parentBabylonNode && parentBabylonNode.getChildren().length == 1) {\r\n                        const parentNode = this._exporter._nodes[nodeMap[parentBabylonNode.uniqueId]];\r\n                        if (parentNode) {\r\n                            const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n                            const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n                            const parentScale = Vector3.FromArrayToRef(parentNode.scale || [1, 1, 1], 0, TmpVectors.Vector3[1]);\r\n                            const parentMatrix = Matrix.ComposeToRef(parentScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);\r\n\r\n                            const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);\r\n                            const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);\r\n                            const matrix = Matrix.ComposeToRef(Vector3.OneReadOnly, rotation, translation, TmpVectors.Matrix[1]);\r\n\r\n                            parentMatrix.multiplyToRef(matrix, matrix);\r\n                            matrix.decompose(parentScale, parentRotation, parentTranslation);\r\n\r\n                            if (parentTranslation.equalsToFloats(0, 0, 0)) {\r\n                                delete parentNode.translation;\r\n                            } else {\r\n                                parentNode.translation = parentTranslation.asArray();\r\n                            }\r\n\r\n                            if (Quaternion.IsIdentity(parentRotation)) {\r\n                                delete parentNode.rotation;\r\n                            } else {\r\n                                parentNode.rotation = parentRotation.asArray();\r\n                            }\r\n\r\n                            if (parentScale.equalsToFloats(1, 1, 1)) {\r\n                                delete parentNode.scale;\r\n                            } else {\r\n                                parentNode.scale = parentScale.asArray();\r\n                            }\r\n\r\n                            parentNode.extensions ||= {};\r\n                            parentNode.extensions[NAME] = lightReference;\r\n\r\n                            // Do not export the original node\r\n                            resolve(null);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    node.extensions ||= {};\r\n                    node.extensions[NAME] = lightReference;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n_Exporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n"]}